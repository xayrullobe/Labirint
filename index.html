<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Labirint O'yini</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
        }
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
        }
        .hud-title {
            font-size: 18px;
            margin-bottom: 8px;
        }
        .hud-controls {
            font-size: 14px;
            opacity: 0.9;
        }
        .level-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 18px;
        }
        .win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
        }
        .win-screen.show {
            display: block;
        }
        .win-emoji {
            font-size: 48px;
            margin-bottom: 20px;
        }
        .win-title {
            font-size: 32px;
            margin-bottom: 10px;
        }
        .win-stats {
            font-size: 20px;
            margin-bottom: 30px;
        }
        .restart-btn {
            background: #00ff00;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            color: black;
            font-weight: bold;
        }
        .restart-btn:hover {
            background: #00dd00;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="hud">
        <div class="hud-title">‚è±Ô∏è Vaqt: <span id="timer">0</span>s</div>
        <div class="hud-controls">
            <div>W/‚Üë - Oldinga</div>
            <div>S/‚Üì - Orqaga</div>
            <div>A/‚Üê - Chapga burilish</div>
            <div>D/‚Üí - O'ngga burilish</div>
        </div>
    </div>

    <div class="level-info">
        üéÆ Bosqich: <span id="level">1</span>
    </div>

    <div class="win-screen" id="winScreen">
        <div class="win-emoji">üéâ</div>
        <div class="win-title">G'alaba!</div>
        <div class="win-stats">
            Bosqich: <span id="winLevel"></span><br>
            Vaqt: <span id="winTime"></span>s
        </div>
        <button class="restart-btn" onclick="nextLevel()">Keyingi bosqich</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let walls = [];
        let exitPos = null;
        let keys = {};
        let won = false;
        let startTime = Date.now();
        let currentLevel = 1;
        let usedMazes = [];

        const moveSpeed = 0.1;
        const rotateSpeed = 0.03;
        const wallSize = 4;
        const wallHeight = 3;

        // Oldindan tayyorlangan turli labirintlar
        const allMazes = [
            // Labirint 1
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 1, 0, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 1, 1, 1, 1, 0, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            // Labirint 2
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 0, 1, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 1, 1, 1, 1, 0, 0, 1, 0, 1],
                [1, 0, 0, 0, 1, 0, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            // Labirint 3
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                [1, 1, 1, 0, 1, 0, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
                [1, 0, 1, 0, 1, 0, 0, 0, 1, 1],
                [1, 0, 0, 0, 1, 1, 1, 0, 0, 1],
                [1, 1, 1, 0, 0, 0, 1, 0, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            // Labirint 4
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 1, 1, 1, 1, 0, 1, 0, 1],
                [1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                [1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 1, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 1, 1, 1, 1, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            // Labirint 5
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
                [1, 0, 0, 0, 0, 1, 0, 0, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            // Labirint 6
            [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                [1, 1, 1, 0, 1, 0, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 0, 1, 1],
                [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                [1, 1, 1, 1, 1, 0, 0, 0, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ]
        ];

        function getRandomUnusedMaze() {
            if (usedMazes.length === allMazes.length) {
                usedMazes = [];
            }
            
            const availableMazes = allMazes.filter((_, index) => !usedMazes.includes(index));
            const randomIndex = Math.floor(Math.random() * availableMazes.length);
            const selectedMazeIndex = allMazes.indexOf(availableMazes[randomIndex]);
            
            usedMazes.push(selectedMazeIndex);
            return allMazes[selectedMazeIndex];
        }

        function init() {
            const canvas = document.getElementById('gameCanvas');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            loadMaze();

            // Event listeners
            window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            window.addEventListener('resize', onWindowResize);

            animate();
            updateTimer();
        }

        function loadMaze() {
            // Clear previous maze
            while(scene.children.length > 2) { 
                scene.remove(scene.children[2]);
            }
            walls = [];
            exitPos = null;
            won = false;

            const mazeLayout = getRandomUnusedMaze();

            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0xd2b48c });
            const exitMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00, 
                emissive: 0x00ff00,
                emissiveIntensity: 0.3 
            });

            mazeLayout.forEach((row, z) => {
                row.forEach((cell, x) => {
                    // Floor
                    const floor = new THREE.Mesh(
                        new THREE.BoxGeometry(wallSize, 0.1, wallSize),
                        floorMaterial
                    );
                    floor.position.set(x * wallSize, 0, z * wallSize);
                    floor.receiveShadow = true;
                    scene.add(floor);

                    if (cell === 1) {
                        // Wall
                        const wall = new THREE.Mesh(
                            new THREE.BoxGeometry(wallSize, wallHeight, wallSize),
                            wallMaterial
                        );
                        wall.position.set(x * wallSize, wallHeight / 2, z * wallSize);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        walls.push({ x: x * wallSize, z: z * wallSize });
                    } else if (cell === 2) {
                        // Exit
                        const exit = new THREE.Mesh(
                            new THREE.BoxGeometry(wallSize, 0.5, wallSize),
                            exitMaterial
                        );
                        exit.position.set(x * wallSize, 0.3, z * wallSize);
                        scene.add(exit);
                        exitPos = { x: x * wallSize, z: z * wallSize };
                    }
                });
            });

            // Reset player position
            camera.position.set(wallSize, 1.5, wallSize);
            camera.rotation.y = 0;
            startTime = Date.now();
        }

        function checkCollision(x, z) {
            const collisionDistance = 1.5;
            for (const wall of walls) {
                const dx = x - wall.x;
                const dz = z - wall.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < collisionDistance) return true;
            }
            return false;
        }

        function checkWin(x, z) {
            if (!exitPos) return false;
            const dx = x - exitPos.x;
            const dz = z - exitPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            return distance < 2;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!won) {
                let newX = camera.position.x;
                let newZ = camera.position.z;

                if (keys['w'] || keys['arrowup']) {
                    newX -= Math.sin(camera.rotation.y) * moveSpeed;
                    newZ -= Math.cos(camera.rotation.y) * moveSpeed;
                }
                if (keys['s'] || keys['arrowdown']) {
                    newX += Math.sin(camera.rotation.y) * moveSpeed;
                    newZ += Math.cos(camera.rotation.y) * moveSpeed;
                }
                if (keys['a'] || keys['arrowleft']) {
                    camera.rotation.y += rotateSpeed;
                }
                if (keys['d'] || keys['arrowright']) {
                    camera.rotation.y -= rotateSpeed;
                }

                if (!checkCollision(newX, newZ)) {
                    camera.position.x = newX;
                    camera.position.z = newZ;
                }

                if (checkWin(camera.position.x, camera.position.z)) {
                    won = true;
                    showWinScreen();
                }
            }

            renderer.render(scene, camera);
        }

        function updateTimer() {
            if (!won) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('timer').textContent = elapsed;
            }
            setTimeout(updateTimer, 1000);
        }

        function showWinScreen() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('winLevel').textContent = currentLevel;
            document.getElementById('winTime').textContent = elapsed;
            document.getElementById('winScreen').classList.add('show');
        }

        function nextLevel() {
            document.getElementById('winScreen').classList.remove('show');
            currentLevel++;
            document.getElementById('level').textContent = currentLevel;
            loadMaze();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>